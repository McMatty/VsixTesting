// Copyright(c) .NET Foundation and Contributors
// All Rights Reserved
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// https://github.com/xunit/xunit
// <autogenerated />

#define XUNIT_FRAMEWORK

namespace Xunit.Internal
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Linq;
    using System.Reflection;
    using System.Text;
    using Xunit.Abstractions;

    class XunitSerializationInfo : IXunitSerializationInfo
    {
        readonly IDictionary<string, XunitSerializationTriple> data = new Dictionary<string, XunitSerializationTriple>();

        public XunitSerializationInfo(IXunitSerializable @object = null)
        {
            if (@object != null)
                @object.Serialize(this);
        }

        public void AddValue(string key, object value, Type type = null)
        {
            if (type == null)
                type = value == null ? typeof(object) : value.GetType();

            data[key] = new XunitSerializationTriple(key, value, type);
        }

        public T GetValue<T>(string key)
        {
            return (T)GetValue(key, typeof(T));
        }

        public object GetValue(string key, Type type)
        {
            XunitSerializationTriple val;

            if (data.TryGetValue(key, out val))
                return val.Value;

            if (type.IsValueType())
                return Activator.CreateInstance(type);

            return null;
        }

        public string ToSerializedString()
        {
            return ToBase64(string.Join("\n", data.Select(kvp => SerializeTriple(kvp.Value)).ToArray()));
        }

        public static string SerializeTriple(XunitSerializationTriple triple)
        {
            var serializedType = SerializationHelper.GetTypeNameForSerialization(triple.Type);
            var serializedValue = Serialize(triple.Value);
            // Leaving off the colon is how we indicate null-ness
            if (serializedValue == null)
                return $"{triple.Key}:{serializedType}";

            return $"{triple.Key}:{serializedType}:{serializedValue}";
        }

        public static XunitSerializationTriple DeserializeTriple(string value)
        {
            var pieces = value.Split(new[] { ':' }, 3);
            if (pieces.Length < 2)
                throw new ArgumentException("Data does not appear to be a valid serialized triple: " + value);

            var pieceType = SerializationHelper.GetType(pieces[1]);
            var deserializedValue = pieces.Length == 3 ? Deserialize(pieceType, pieces[2]) : null;

            return new XunitSerializationTriple(pieces[0], deserializedValue, pieceType);
        }

        public static object Deserialize(Type type, string serializedValue)
        {
            if (serializedValue == null)
                return null;

            if (typeof(IXunitSerializable).IsAssignableFrom(type))
                return DeserializeSerializable(type, serializedValue);

            if (type == typeof(char?) || type == typeof(char))
                return (char)ushort.Parse(serializedValue, CultureInfo.InvariantCulture);

            if (type == typeof(string))
                return FromBase64(serializedValue);

            if (type == typeof(byte?) || type == typeof(byte))
                return byte.Parse(serializedValue, CultureInfo.InvariantCulture);

            if (type == typeof(sbyte?) || type == typeof(sbyte))
                return sbyte.Parse(serializedValue, CultureInfo.InvariantCulture);

            if (type == typeof(short?) || type == typeof(short))
                return short.Parse(serializedValue, CultureInfo.InvariantCulture);

            if (type == typeof(ushort?) || type == typeof(ushort))
                return ushort.Parse(serializedValue, CultureInfo.InvariantCulture);

            if (type == typeof(int?) || type == typeof(int))
                return int.Parse(serializedValue, CultureInfo.InvariantCulture);

            if (type == typeof(uint?) || type == typeof(uint))
                return uint.Parse(serializedValue, CultureInfo.InvariantCulture);

            if (type == typeof(long?) || type == typeof(long))
                return long.Parse(serializedValue, CultureInfo.InvariantCulture);

            if (type == typeof(ulong?) || type == typeof(ulong))
                return ulong.Parse(serializedValue, CultureInfo.InvariantCulture);

            if (type == typeof(float?) || type == typeof(float))
            {
                var arrSer = (ArraySerializer)DeserializeSerializable(typeof(ArraySerializer), serializedValue);
                byte[] bytes = (byte[])arrSer.ArrayData;
                return BitConverter.ToSingle(bytes, 0);
            }

            if (type == typeof(double?) || type == typeof(double))
            {
                var arrSer = (ArraySerializer)DeserializeSerializable(typeof(ArraySerializer), serializedValue);
                byte[] bytes = (byte[])arrSer.ArrayData;
                return BitConverter.ToDouble(bytes, 0);
            }

            if (type == typeof(decimal?) || type == typeof(decimal))
                return decimal.Parse(serializedValue, CultureInfo.InvariantCulture);

            if (type == typeof(bool?) || type == typeof(bool))
                return bool.Parse(serializedValue);

            if (type == typeof(DateTime?) || type == typeof(DateTime))
            {
                var styles = serializedValue.EndsWith("Z", StringComparison.Ordinal) ? DateTimeStyles.AdjustToUniversal : DateTimeStyles.None;
                return DateTime.Parse(serializedValue, CultureInfo.InvariantCulture, styles);
            }

            if (type == typeof(DateTimeOffset?) || type == typeof(DateTimeOffset))
            {
                var styles = serializedValue.EndsWith("Z", StringComparison.Ordinal) ? DateTimeStyles.AdjustToUniversal : DateTimeStyles.None;
                return DateTimeOffset.Parse(serializedValue, CultureInfo.InvariantCulture, styles);
            }

            if (type == typeof(Type))
                return SerializationHelper.GetType(serializedValue);

            if (type.IsEnum() || type.IsNullableEnum())
                return Enum.Parse(type.UnwrapNullable(), serializedValue);

            if (type.IsArray)
            {
                var arrSer = (ArraySerializer)DeserializeSerializable(typeof(ArraySerializer), serializedValue);
                return arrSer.ArrayData;
            }

            throw new ArgumentException("We don't know how to de-serialize type " + type.FullName, nameof(serializedValue));
        }

        static IXunitSerializable DeserializeSerializable(Type type, string serializedValue)
        {
            var serializationInfo = new XunitSerializationInfo();

            // Will end up with an empty string if the serialization type did not serialize any data
            if (serializedValue != string.Empty)
            {
                var elements = FromBase64(serializedValue).Split('\n');

                foreach (var element in elements)
                {
                    var triple = DeserializeTriple(element);
                    serializationInfo.data[triple.Key] = triple;
                }
            }

            try
            {
                var value = (IXunitSerializable)Activator.CreateInstance(type);
                value.Deserialize(serializationInfo);
                return value;
            }
            catch (MissingMemberException)
            {
                throw new InvalidOperationException($"Could not de-serialize type '{type.FullName}' because it lacks a parameterless constructor.");
            }
        }

        public static string Serialize(object value)
        {
            if (value == null)
                return null;

            var serializable = value as IXunitSerializable;
            if (serializable != null)
            {
                var info = new XunitSerializationInfo();
                serializable.Serialize(info);
                return info.ToSerializedString();
            }

            var charData = value as char?;
            if (charData != null)
                return ((ushort)charData.GetValueOrDefault()).ToString(CultureInfo.InvariantCulture);

            var stringData = value as string;
            if (stringData != null)
                return ToBase64(stringData);

            var byteData = value as byte?;
            if (byteData != null)
                return byteData.GetValueOrDefault().ToString(CultureInfo.InvariantCulture);

            var sbyteData = value as sbyte?;
            if (sbyteData != null)
                return sbyteData.GetValueOrDefault().ToString(CultureInfo.InvariantCulture);

            var ushortData = value as ushort?;
            if (ushortData != null)
                return ushortData.GetValueOrDefault().ToString(CultureInfo.InvariantCulture);

            var shortData = value as short?;
            if (shortData != null)
                return shortData.GetValueOrDefault().ToString(CultureInfo.InvariantCulture);

            var uintData = value as uint?;
            if (uintData != null)
                return uintData.GetValueOrDefault().ToString(CultureInfo.InvariantCulture);

            var intData = value as int?;
            if (intData != null)
                return intData.GetValueOrDefault().ToString(CultureInfo.InvariantCulture);

            var ulongData = value as ulong?;
            if (ulongData != null)
                return ulongData.GetValueOrDefault().ToString(CultureInfo.InvariantCulture);

            var longData = value as long?;
            if (longData != null)
                return longData.GetValueOrDefault().ToString(CultureInfo.InvariantCulture);

            var floatData = value as float?;
            if (floatData != null)
            {
                var info = new XunitSerializationInfo();
                var arraySer = new ArraySerializer(BitConverter.GetBytes(floatData.GetValueOrDefault()));
                arraySer.Serialize(info);
                return info.ToSerializedString();
            }

            var doubleData = value as double?;
            if (doubleData != null)
            {
                var info = new XunitSerializationInfo();
                var arraySer = new ArraySerializer(BitConverter.GetBytes(doubleData.GetValueOrDefault()));
                arraySer.Serialize(info);
                return info.ToSerializedString();
            }

            var decimalData = value as decimal?;
            if (decimalData != null)
                return decimalData.GetValueOrDefault().ToString(CultureInfo.InvariantCulture);

            var booleanData = value as bool?;
            if (booleanData != null)
                return booleanData.GetValueOrDefault().ToString();

            var datetimeData = value as DateTime?;
            if (datetimeData != null)
                return datetimeData.GetValueOrDefault().ToString("o", CultureInfo.InvariantCulture);  // Round-trippable format

            var datetimeoffsetData = value as DateTimeOffset?;
            if (datetimeoffsetData != null)
                return datetimeoffsetData.GetValueOrDefault().ToString("o", CultureInfo.InvariantCulture);  // Round-trippable format

            var typeData = value as Type;
            if (typeData != null)
                return SerializationHelper.GetTypeNameForSerialization(typeData);

            var valueType = value.GetType();
            if (valueType.IsEnum())
            {
                if (!valueType.IsFromLocalAssembly())
                    throw new ArgumentException($"We cannot serialize enum {valueType.FullName}.{value} because it lives in the GAC", nameof(value));
                return value.ToString();
            }

            var arrayData = value as Array;
            if (arrayData != null)
            {
                var info = new XunitSerializationInfo();
                var arraySer = new ArraySerializer(arrayData);
                arraySer.Serialize(info);
                return info.ToSerializedString();
            }

            throw new ArgumentException($"We don't know how to serialize type {valueType.FullName}", nameof(value));
        }

        static readonly Type[] supportedSerializationTypes = {
            typeof(IXunitSerializable),
            typeof(char),           typeof(char?),
            typeof(string),
            typeof(byte),           typeof(byte?),
            typeof(sbyte),          typeof(sbyte?),
            typeof(short),          typeof(short?),
            typeof(ushort),         typeof(ushort?),
            typeof(int),            typeof(int?),
            typeof(uint),           typeof(uint?),
            typeof(long),           typeof(long?),
            typeof(ulong),          typeof(ulong?),
            typeof(float),          typeof(float?),
            typeof(double),         typeof(double?),
            typeof(decimal),        typeof(decimal?),
            typeof(bool),           typeof(bool?),
            typeof(DateTime),       typeof(DateTime?),
            typeof(DateTimeOffset), typeof(DateTimeOffset?),
        };

        internal static bool CanSerializeObject(object value)
        {
            if (value == null)
                return true;

            var valueType = value.GetType();

            if (valueType.IsArray)
            {
                var vector = value as object[];
                if (vector != null)
                {
                    // Avoid enumerator allocation and bounds lookups that comes from enumerating a System.Array
                    foreach (object obj in vector)
                        if (!CanSerializeObject(obj))
                            return false;
                }
                else
                {
                    foreach (object obj in ((Array)value))
                        if (!CanSerializeObject(obj))
                            return false;
                }
                return true;
            }

            foreach (Type supportedType in supportedSerializationTypes)
                if (supportedType.IsAssignableFrom(valueType))
                    return true;

            Type typeToCheck = valueType;
            if (valueType.IsEnum() || valueType.IsNullableEnum() || (typeToCheck = value as Type) != null)
                return typeToCheck.IsFromLocalAssembly();

            return false;
        }

        static string FromBase64(string serializedValue)
        {
            var bytes = Convert.FromBase64String(serializedValue);
            return Encoding.UTF8.GetString(bytes, 0, bytes.Length);
        }

        static string ToBase64(string value)
        {
            var bytes = Encoding.UTF8.GetBytes(value);
            return Convert.ToBase64String(bytes);
        }

        internal class ArraySerializer : IXunitSerializable
        {
            Array array;
            readonly Type elementType;

            public Array ArrayData { get { return array; } }

            public ArraySerializer() { }

            public ArraySerializer(Array array)
            {
                if (array == null)
                    throw new ArgumentNullException(nameof(array));

                if (!CanSerializeObject(array))
                    throw new ArgumentException("There is at least one object in this array that cannot be serialized", nameof(array));

                this.array = array;
                elementType = array.GetType().GetElementType();
            }

            public void Serialize(IXunitSerializationInfo info)
            {
                info.AddValue("ElementType", SerializationHelper.GetTypeNameForSerialization(elementType));
                info.AddValue("Rank", array.Rank);
                info.AddValue("TotalLength", array.Length);

                for (int dimension = 0; dimension < array.Rank; dimension++)
                {
                    info.AddValue("Length" + dimension, array.GetLength(dimension));
                }
                for (int dimension = 0; dimension < array.Rank; dimension++)
                {
                    info.AddValue("LowerBound" + dimension, array.GetLowerBound(dimension));
                }

                int i = 0;
                foreach (object obj in array)
                {
                    info.AddValue("Item" + i, obj);
                    i++;
                }
            }

            public void Deserialize(IXunitSerializationInfo info)
            {
                var arrType = SerializationHelper.GetType(info.GetValue<string>("ElementType"));
                var rank = info.GetValue<int>("Rank");
                var totalLength = info.GetValue<int>("TotalLength");

                int[] lengths = new int[rank];
                int[] lowerBounds = new int[rank];
                for (int i = 0; i < lengths.Length; i++)
                {
                    lengths[i] = info.GetValue<int>("Length" + i);
                    lowerBounds[i] = info.GetValue<int>("LowerBound" + i);
                }

                array = Array.CreateInstance(arrType, lengths, lowerBounds);

                int[] indices = new int[rank];
                for (int i = 0; i < indices.Length; i++)
                {
                    indices[i] = lowerBounds[i];
                }
                for (int i = 0; i < totalLength; i++)
                {
                    bool complete = false;
                    for (int dim = rank - 1; dim >= 0; dim--)
                    {
                        if (indices[dim] >= lowerBounds[dim] + lengths[dim])
                        {
                            if (dim == 0)
                            {
                                complete = true;
                                break;
                            }
                            for (int j = dim; j < rank; j++)
                                indices[j] = lowerBounds[dim];
                            indices[dim - 1]++;
                        }
                    }
                    if (complete)
                    {
                        break;
                    }
                    object item = info.GetValue("Item" + i, arrType);
                    array.SetValue(item, indices);
                    indices[rank - 1]++;
                }
            }
        }
    }

    class XunitSerializationTriple
    {
        public readonly string Key;
        public readonly object Value;
        public readonly Type Type;

        public XunitSerializationTriple(string key, object value, Type type)
        {
            Key = key;
            Value = value;
            Type = type;
        }
    }

    static class SerializationHelper
    {
        static readonly ConcurrentDictionary<Type, string> typeToTypeNameMap = new ConcurrentDictionary<Type, string>();

        public static T Deserialize<T>(string serializedValue)
        {
            if (serializedValue == null)
                throw new ArgumentNullException(nameof(serializedValue));

            var pieces = serializedValue.Split(new[] { ':' }, 2);
            if (pieces.Length != 2)
                throw new ArgumentException("De-serialized string is in the incorrect format.");

            var deserializedType = GetType(pieces[0]);
            if (deserializedType == null)
                throw new ArgumentException($"Could not load type '{pieces[0]}' from serialization value '{serializedValue}'", nameof(serializedValue));

            if (!typeof(IXunitSerializable).IsAssignableFrom(deserializedType))
                throw new ArgumentException("Cannot de-serialize an object that does not implement " + typeof(IXunitSerializable).FullName, nameof(serializedValue));

            var obj = XunitSerializationInfo.Deserialize(deserializedType, pieces[1]);
            var arraySerializer = obj as XunitSerializationInfo.ArraySerializer;
            if (arraySerializer != null)
                obj = arraySerializer.ArrayData;

            return (T)obj;
        }

        public static string Serialize(object value)
        {
            if (value == null)
                throw new ArgumentNullException(nameof(value));

            var array = value as object[];
            if (array != null)
                value = new XunitSerializationInfo.ArraySerializer(array);

            var serializable = value as IXunitSerializable;
            if (serializable == null)
                throw new ArgumentException("Cannot serialize an object that does not implement " + typeof(IXunitSerializable).FullName, nameof(value));

            var serializationInfo = new XunitSerializationInfo(serializable);
            return $"{GetTypeNameForSerialization(value.GetType())}:{serializationInfo.ToSerializedString()}";
        }

        public static bool IsSerializable(object value)
        {
            return XunitSerializationInfo.CanSerializeObject(value);
        }

        public static Type GetType(string assemblyQualifiedTypeName)
        {
            var firstOpenSquare = assemblyQualifiedTypeName.IndexOf('[');
            if (firstOpenSquare > 0)
            {
                var backtick = assemblyQualifiedTypeName.IndexOf('`');
                if (backtick > 0 && backtick < firstOpenSquare)
                {
                    // Run the string looking for the matching closing square brace. Can't just assume the last one
                    // is the end, since the type could be trailed by array designators.
                    var depth = 1;
                    var lastOpenSquare = firstOpenSquare + 1;
                    var sawNonArrayDesignator = false;
                    for (; depth > 0 && lastOpenSquare < assemblyQualifiedTypeName.Length; ++lastOpenSquare)
                    {
                        switch (assemblyQualifiedTypeName[lastOpenSquare])
                        {
                            case '[': ++depth; break;
                            case ']': --depth; break;
                            case ',': break;
                            default: sawNonArrayDesignator = true; break;
                        }
                    }

                    if (sawNonArrayDesignator)
                    {
                        if (depth != 0)  // Malformed, because we never closed what we opened
                            return null;

                        var genericArgument = assemblyQualifiedTypeName.Substring(firstOpenSquare + 1, lastOpenSquare - firstOpenSquare - 2);  // Strip surrounding [ and ]
                        var innerTypeNames = SplitAtOuterCommas(genericArgument).Select(x => x.Substring(1, x.Length - 2));  // Strip surrounding [ and ] from each type name
                        var innerTypes = innerTypeNames.Select(s => GetType(s)).ToArray();
                        if (innerTypes.Any(t => t == null))
                            return null;

                        var genericDefinitionName = assemblyQualifiedTypeName.Substring(0, firstOpenSquare) + assemblyQualifiedTypeName.Substring(lastOpenSquare);
                        var genericDefinition = GetType(genericDefinitionName);
                        if (genericDefinition == null)
                            return null;

                        // Push array ranks so we can get down to the actual generic definition
                        var arrayRanks = new Stack<int>();
                        while (genericDefinition.IsArray)
                        {
                            arrayRanks.Push(genericDefinition.GetArrayRank());
                            genericDefinition = genericDefinition.GetElementType();
                        }

                        var closedGenericType = genericDefinition.MakeGenericType(innerTypes);
                        while (arrayRanks.Count > 0)
                        {
                            var rank = arrayRanks.Pop();
                            closedGenericType = rank > 1 ? closedGenericType.MakeArrayType(rank) : closedGenericType.MakeArrayType();
                        }

                        return closedGenericType;
                    }
                }
            }

            IList<string> parts = SplitAtOuterCommas(assemblyQualifiedTypeName, true);
            return
                parts.Count == 0 ? null :
                parts.Count == 1 ? Type.GetType(parts[0]) :
                GetType(parts[1], parts[0]);
        }

        public static Type GetType(string assemblyName, string typeName)
        {
#if XUNIT_FRAMEWORK    // This behavior is only for v2, and only done on the remote app domain side
            if (assemblyName.EndsWith(ExecutionHelper.SubstitutionToken, StringComparison.OrdinalIgnoreCase))
                assemblyName = assemblyName.Substring(0, assemblyName.Length - ExecutionHelper.SubstitutionToken.Length + 1) + ExecutionHelper.PlatformSuffix;
#endif

#if NET35 || NET452
            // Support both long name ("assembly, version=x.x.x.x, etc.") and short name ("assembly")
            var assembly = AppDomain.CurrentDomain.GetAssemblies().FirstOrDefault(a => a.FullName == assemblyName || a.GetName().Name == assemblyName);
            if (assembly == null)
            {
                try
                {
                    assembly = Assembly.Load(assemblyName);
                }
                catch { }
            }
#else
            Assembly assembly = null;
            try
            {
                // Make sure we only use the short form
                var an = new AssemblyName(assemblyName);
                assembly = Assembly.Load(new AssemblyName { Name = an.Name, Version = an.Version });

            }
            catch { }
#endif

            if (assembly == null)
                return null;

            return assembly.GetType(typeName);
        }

        public static string GetTypeNameForSerialization(Type type)
        {
            // Use the abstract Type instead of concretes like RuntimeType
            if (typeof(Type).IsAssignableFrom(type))
                type = typeof(Type);

            return typeToTypeNameMap.GetOrAdd(type, GetTypeNameAsString);

            string GetTypeNameAsString(Type typeToMap)
            {
                if (!type.IsFromLocalAssembly())
                    throw new ArgumentException($"We cannot serialize type {type.FullName} because it lives in the GAC", nameof(type));

                var typeName = typeToMap.FullName;
                var assemblyName = typeToMap.GetAssembly().FullName.Split(',')[0];

                var arrayRanks = new Stack<int>();
                while (typeToMap.IsArray)
                {
                    arrayRanks.Push(typeToMap.GetArrayRank());
                    typeToMap = typeToMap.GetElementType();
                }

                if (typeToMap.IsGenericType() && !typeToMap.IsGenericTypeDefinition())
                {
                    var typeDefinition = typeToMap.GetGenericTypeDefinition();
                    var innerTypes = typeToMap.GetGenericArguments()
                                              .Select(t => $"[{GetTypeNameForSerialization(t)}]")
                                              .ToArray();
                    typeName = $"{typeDefinition.FullName}[{string.Join(",", innerTypes)}]";

                    while (arrayRanks.Count > 0)
                    {
                        typeName += '[';
                        for (var commas = arrayRanks.Pop() - 1; commas > 0; --commas)
                            typeName += ',';
                        typeName += ']';
                    }
                }

                if (string.Equals(assemblyName, "mscorlib", StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(assemblyName, "System.Private.CoreLib", StringComparison.OrdinalIgnoreCase))
                    return typeName;

#if XUNIT_FRAMEWORK // This behavior is only for v2, and only done on the remote app domain side
                // If this is a platform specific assembly, strip off the trailing . and name and replace it with the token
                if (typeToMap.GetAssembly().GetCustomAttributes().FirstOrDefault(a => a != null && a.GetType().FullName == "Xunit.Sdk.PlatformSpecificAssemblyAttribute") != null)
                    assemblyName = assemblyName.Substring(0, assemblyName.LastIndexOf('.')) + ExecutionHelper.SubstitutionToken;
#endif

                return $"{typeName}, {assemblyName}";
            }
        }

        static string SubstringTrim(string str, int startIndex, int length)
        {
            int endIndex = startIndex + length;

            while (startIndex < endIndex && char.IsWhiteSpace(str[startIndex]))
                startIndex++;

            while (endIndex > startIndex && char.IsWhiteSpace(str[endIndex - 1]))
                endIndex--;

            return str.Substring(startIndex, endIndex - startIndex);
        }

        static IList<string> SplitAtOuterCommas(string value, bool trimWhitespace = false)
        {
            var results = new List<string>();

            var startIndex = 0;
            var endIndex = 0;
            var depth = 0;

            for (; endIndex < value.Length; ++endIndex)
            {
                switch (value[endIndex])
                {
                    case '[': ++depth; break;
                    case ']': --depth; break;
                    case ',':
                        if (depth == 0)
                        {
                            results.Add(trimWhitespace ?
                                SubstringTrim(value, startIndex, endIndex - startIndex) :
                                value.Substring(startIndex, endIndex - startIndex));
                            startIndex = endIndex + 1;
                        }
                        break;
                }
            }

            if (depth != 0 || startIndex >= endIndex)
            {
                results.Clear();
            }
            else
            {
                results.Add(trimWhitespace ?
                    SubstringTrim(value, startIndex, endIndex - startIndex) :
                    value.Substring(startIndex, endIndex - startIndex));
            }

            return results;
        }
    }

    static class NewReflectionExtensions
    {
        // New methods

        public static Assembly GetAssembly(this Type type)
        {
#if NET35
        return type.Assembly;
#else
            return type.GetTypeInfo().Assembly;
#endif
        }

        public static Attribute[] GetCustomAttributes(this Assembly assembly)
        {
#if NET35
        return assembly.GetCustomAttributes(false).Cast<Attribute>().ToArray();
#else
            return assembly.GetCustomAttributes<Attribute>().ToArray();
#endif
        }

        public static bool IsEnum(this Type type)
        {
#if NET35
        return type.IsEnum;
#else
            return type.GetTypeInfo().IsEnum;
#endif
        }

        public static bool IsFromLocalAssembly(this Type type)
        {
            var assemblyName = type.GetAssembly().GetName().Name;

            try
            {
#if NET35
            Assembly.Load(assemblyName);
#else
                Assembly.Load(new AssemblyName { Name = assemblyName });
#endif
                return true;
            }
            catch
            {
                return false;
            }
        }

        public static bool IsGenericType(this Type type)
        {
#if NET35
        return type.IsGenericType;
#else
            return type.GetTypeInfo().IsGenericType;
#endif
        }

        public static bool IsGenericTypeDefinition(this Type type)
        {
#if NET35
        return type.IsGenericTypeDefinition;
#else
            return type.GetTypeInfo().IsGenericTypeDefinition;
#endif
        }

        public static bool IsNullableEnum(this Type type)
        {
            return type.IsGenericType() && type.GetGenericTypeDefinition() == typeof(Nullable<>) && type.GetGenericArguments()[0].IsEnum();
        }

        public static bool IsValueType(this Type type)
        {
#if NET35
        return type.IsValueType;
#else
            return type.GetTypeInfo().IsValueType;
#endif
        }

        public static Type UnwrapNullable(this Type type)
        {
            if (!type.IsGenericType())
                return type;
            if (type.GetGenericTypeDefinition() != typeof(Nullable<>))
                return type;
            return type.GetGenericArguments()[0];
        }

        // Existing methods

#if !NET35
        public static Type[] GetGenericArguments(this Type type)
        {
            return type.GetTypeInfo().GenericTypeArguments;
        }

        public static Type[] GetInterfaces(this Type type)
        {
            return type.GetTypeInfo().ImplementedInterfaces.ToArray();
        }

        public static bool IsAssignableFrom(this Type type, Type otherType)
        {
            return type.GetTypeInfo().IsAssignableFrom(otherType.GetTypeInfo());
        }
#endif
    }

    static class ExecutionHelper
    {
        static readonly string executionAssemblyNamePrefix = "xunit.execution.";
        static string platformSuffix = "__unknown__";
#if NETSTANDARD1_1
        static readonly string[] platformSuffixes = new[] { "dotnet", "MonoAndroid", "MonoTouch", "iOS-Universal", "universal", "win8", "wp8" };
#elif NETSTANDARD
        static readonly string[] platformSuffixes = new[] { "dotnet", "MonoAndroid", "iOS-Universal" };
#endif

        public static string PlatformSuffix
        {
            get
            {
                lock (executionAssemblyNamePrefix)
                {
                    if (platformSuffix == "__unknown__")
                    {
                        platformSuffix = null;

#if NETSTANDARD
                        foreach (var suffix in platformSuffixes)
                            try
                            {
                                Assembly.Load(new AssemblyName { Name = executionAssemblyNamePrefix + suffix });
                                platformSuffix = suffix;
                                break;
                            }
                            catch { }
#else
                        foreach (var name in AppDomain.CurrentDomain.GetAssemblies().Select(a => a?.GetName()?.Name))
                            if (name != null && name.StartsWith(executionAssemblyNamePrefix, StringComparison.Ordinal))
                            {
                                platformSuffix = name.Substring(executionAssemblyNamePrefix.Length);
                                break;
                            }
#endif
                    }
                }

                if (platformSuffix == null)
                    throw new InvalidOperationException($"Could not find any xunit.execution.* assembly loaded in the current context");

                return platformSuffix;
            }
        }

        public static readonly string SubstitutionToken = ".{Platform}";
    }
}